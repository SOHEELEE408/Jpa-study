####🔅 Order에 MemberId를 쓰는 것은 객체지향스럽지 않다.
```
* orderId를 통해서 Member 조회

Order order = em.find(Order.class, 1L);
Long memberId = order.getMemberId();

Member member = em.find(Member.class, memberId);

➡ 번거로운 조회과정을 거쳐야 한다.
```

* memberId 보다는 Member 자체를 사용

```
@Column(name = "MEMBER_ID")
private Long memberId;
```
➡ 이런 식의 설계는 관계형 DB에 맞추는 설계이다.

***

#### 🔅 연관관계 매핑 - 양방향 매핑

* 테이블에서 FK를 갖는 쪽을 연관관계 주인으로 하자.
  - 예) ORDER가 MEMBER_ID라는 FK를 갖는다. Order Entity가 연관관계 주인
  - Member의 List<Order> 는 연관관계 지음을 당한 것.(가짜매핑, mappedBy) >> 읽기 전용으로 조회만 가능하다(update, create ❌)
* 연관 관계 주인에 값을 입력해야 하지만 _**순수한 객체 관계를 고려하면 항상 양쪽 모두에 값을 입력해야 한다.**_
  - 연관 관계 편의 메서드는 한쪽에서만 사용한다.
* 무한 루프를 주의하자.(예. lombok으로 자동 생성된 toString())
  - 컨트롤러에서 Entity를 반환할 때 JSON 생성 라이브러리에 의해 무한 루프에 빠질 수 있다.
    - ❗ 컨트롤러에서 Entity를 반환하지 말자. ➡ Entity에 변경이 있을 수 있기 때문에 API spec에 문제가 생길 수 있다.(DTO를 사용하자.)

##### 양방향 매핑 정리
* 설계시 단방향 매핑만(Many 쪽에서 설정)으로 설계를 완료해야 한다.
* 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐이다.
* Member가 List<Order>를 가지고 있는 것은 설계 상 좋다고 할 수 없다. ➡ 보통 회원의 주문량을 조회할 때 ORDERS 테이블에서 출발하기 때문

---

#### 🔅 다양한 연관관계 매핑
* 일대다 단방향 매핑보다는 **다대일 양방향 매핑**을 사용하자
* RDB의 유니크 제약 조건이 추가된 것이 일대일 매핑이다. ➡ 다대일 단방향 매핑과 유사
* 다대일을 사용하면 그것을 연관관계 주인으로 써야 한다.(스펙상 mappedby 가 없음)
* 다대다 매핑의 한계
  - 서비스를 운영하다 보면 주문시간, 수량같은 데이터가 들어올 수 있는데,이것을 연결 테이블에 넣을 수 없다.
    - 연결 테이블용 엔티티를 추가하자 : @ManyToMany ➡ @OneToMany, @ManyToOne
    - 연결 테이블은 매핑하고자 하는 테이블들의 PK 값을 FK로 갖는데, 이때 이 두 가지 값을 엮어서 PK, FK로 설정하는 것보다 비즈니스적 의미가 없는 값으로 PK를 따로 잡는 것을 권장한다.(장기적으로 볼 때 보다 유연하게 애플리케이션 개발 가능)

***

#### 🔅 상속관계 매핑
* 상속관계 매핑: 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
* 조인전략 
  - @DiscriminatorColumn : 어떤 서브 테이블에서 추가 되었는지 타입을 나타내는 Column을 만들어줌(DTYPE) ➡ 단일 테이블 전략에서는 반드시 필요(해당 어노테이션을 안넣어줘도 생김)
  - @Inheritance(strategy=IngeritanceType.XXX) 
    - JOINED: 조인 전략
    - SINGLE_TABLE: 단일 테이블 전략 - 성능에 유리
    - TABLE_PER_CLASS: 구현 클래스마다 테이블 전략
  - @DiscriminatorValue("XXX")
  - 👍 설계를 수정할 때 소스코드의 여러 곳을 변경할 필요없이 전략부분만 바꿔주면 된다.(JPA의 장점)
  - 비즈니스 적으로 복잡하거나 확장성을 고려해야 한다면 조인 전략, 단순하고 확장성이 적은 경우에는 단일 테이블 전략을 추천한다.(TABLE_PER_CLASSS 이건 쓰지말자.)
* @MappedSuperclass
  - 공통 매핑 정보가 필요할 때 사용(ex. id, name)
  - Entity아님, 상속관계 매핑X
  - 조회, 검색 안됨
  - 직접 생성해서 사용할 일이 없으므로 **추상클래스 권장**
  - 데이터가 많아지면(like 하루에 백만건) 상속관계가 잘 동작하지 않을 수 있다. 관계를 단순하게 가져가는 게 이득일 수 있다.

***

#### 🔅 프록시 / 지연로딩&즉시로딩
* 가급적 지연 로딩만 사용하자.
  - 즉시 로딩을 적용하면 예상치 못한 SQL 발생
  - **즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.**
  - _**@ManyToOne, @OneToOne은 기본이 즉시 로딩**_ ➡ LAZY로 설정
  - @OneToMany, @ManyToMany는 기본이 지연로딩
  
##### 📌 영속성 전이
* 하나의 엔티티가 다른 하나의 엔티티에 연관되어 속해 있을 때 부모 엔티티를 영속성 컨텍스트에 저장하면 속해있는 자식 엔티티도 자동으로 영속성 컨텍스트에 저장되게 하는 것 (영속상태로 만든다)
* 지연로딩, 즉시로딩과는 관계가 없다.
* 단지 계속해서 함께 호출되는 엔티티를 보다 편리하게 관리할 수 있는 설정을 제공
* ➕ CASCADE 종류
  - ALL : 모두 적용
  - PERSIST: 영속
  - REMOVE : 삭제
* ➕ 언제쓸까? 
  - 하나의 부모가 자식을 관리할 때(단일 소유자일 때)
  - 라이프사이클이 같을 때

##### 📌 고아객체 / 영속성 전이 + 고아객체, 생명주기 
* 부모 엔티티에서 배제되는(연관관계가 끊어진) 자식 엔티티는 자동으로 삭제하는 것
* 부모가 삭제되면 자식은 자동으로 삭제된다.
  - ➕ 고아객체 제거 기능을 활성화할 때 동작, 
  - CascadeType.REMOVE 처럼 동작(부모가 삭제되면 자식도 삭제, 하지만 단순히 관계만 끊어지면 자식 객체 삭제X)
  - orphanRemovel = true : 부모와의 관계가 제거되면 자식 삭제됨
  - CascadeType.ALL(부모제거되면 자식도 제거, 영속성전이) + orphanRemovel=true ➡ 두 옵션을 함께 사용하면 부모엔티티를 통해 자식의 생명주기를 관리할 수 있다.
* 실무에서는 유의해서 사용해야 한다. (참조되는 곳이 하나일 때 사용한다.)

---
#### 🔅 값 타입
* 기본값타입
  - int, String과 같은 값 타입
  - '==' 비교가 가능하다.
  - 복사해서 값을 넘겨주어 같은 값을 갖게 되어도 각각 메모리가 할당되기 때문에 이후에 하나의 변수값을 변경한다고 해도 다른 것에는 영향을 주지 않는다.
  - side effect를 염려하지 않아도 된다.
```
int a = 10;
int b = a;

a = 20;

=> b는 여전히 10이다.

```
* 임베디드 타입
  - int, String과 같은 값 타입
  - 여러 엔티티에서 공통으로 갖는 값들을 따로 분리하여 클래스로 만들 수 있다.(새로운 값 타입을 정의할 수 있다)
  - 클래스로 만든다음에 @Embadable을 붙여주고 이것을 가져다 쓰는 엔티티에서 @Embedded를 붙여서 호출하면(@Embeddable 붙였으면 이건 필수는 아님) JPA가 알아서 컬럼으로 넣어준다.
  - 기본 생성자 필수
  - 의미있는 메소드를 만들 수 있다.(예, Period.isWork())
  - 값 타입을 소유한 엔티티에 생명주기를 의존함
  - 하지만 이것은 결국 값 타입이다. 
    - 값을 복사해서 쓴 다음 setXXX()을 이용해서 한쪽의 값을 수정하면 이전에 복사했던 것의 값도 바뀐다.(객체의 경우 복사하면 참조값이 복사됨 => 같은 공간을 가리키고 있는 것)
  - ➕ @AttributeOverride: 속성 재정의
    - 한 엔티티에서 같은 값 타입을 사용하면 컬럼명이 중복됨 
    - @AttributeOverrides, @AttributeOveride를 사용해서 컬럼 명 속성을 재정의
* 값 타입과 불변 객체
  - 값 타입을 사용할 때는 setter를 이용해서 아무데서나 값 변경을 가능하게 만들면 안된다.(setter 안만드는 것을 권장)
    - 값을 변경할 때는 아예 생성자로 새로 짜서 그 부분을 통째로 바꿔준다. ➡ ex. 주소(우편번호, 도로명 주소, 상세주소) 중 우편번호 값을 바꾸고 싶으면, 생성자로 새로 만들어서 우편번호는 변경하고자 하는 값, 나머지는 이전 값을 넣어서 새로 저장해준다.(공통 참조 가능성을 제거)
    - 불변객체를 만들어서 사용하라는 것
    - 불변객체를 만드는 방법은 여러 가지 
* 값 타입의 비교
  - equals를 이용해서 바교하는데, equals의 기본 설정도 '==' 비교이기 때문에 엔티티 클래스에서 오버라이딩해서 사용한다.
    - 동등성(equivalence) 비교: 인스턴스의 값을 비교 / 동일성(identity) 비교: 인스턴스의 참조 값을 비교

##### 📌 값 타입 컬렉션(여기 다시듣기)
* 값 타입을 하나 이상 저장할 때 사용
* @ElementCollection, @CollectionTable 사용
* 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다. ➡ 컬렉션을 저장하기 위한 별도의 테이블이 필요
* **값 타입 컬렉션도 지연 로딩 전략 사용**
* ❗ 값 타입 컬렉션은 영속성 전이+고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.
* 값 타입은 식별자 개념이 없다. ➡ 변경하면 추적이 어려움
* 💥 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.
* 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키는 구성해야 함(null 안됨, 중복 저장 안됨)